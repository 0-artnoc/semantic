[
  {
    "language": "ruby",
    "fileExt": ".rb",
    "repoUrl": "https://github.com/diff-fixtures/ruby.git",
    "syntaxes": [
      {
        "syntax": "assignment",
        "insert": "x = 0",
        "replacement": "x = 1"
      },
      {
        "syntax": "comment",
        "insert": "# This is a comment",
        "replacement": "=begin\nThis is a multiline\ncomment\n=end"
      },
      {
        "syntax": "number",
        "insert": "1234\n1_234\n0d1_234\n0xa_bcd_ef0_123_456_789\n0o1234567\n0b1_0\n1.234_5e678_90\n",
        "replacement": "1235\n1_235\n0d1_235\n0xa_bcd_ef0_123_456_788\n0o1234576\n0b1_1\n1.234_5e678_91\n"
      },
      {
        "syntax": "symbol",
        "insert": ":foo\n:'foo'\n:\"foo\"",
        "replacement": ":bar\n:'bar'\n:\"bar\""
      },
      {
        "syntax": "string",
        "insert": "''\n'foo with \"bar\"'",
        "replacement": "\"\"\n\"bar with 'foo'\""
      },
      {
        "syntax": "interpolation",
        "insert": ":\"foo #{bar}\"\n\"foo #{bar}\"",
        "replacement": ":\"bar #{foo}\"\n\"bar #{foo}\""
      },
      {
        "syntax": "delimiter",
        "insert": "%q#a#\n%q<a<b>c>\n%#a#\n%Q#a#\n%<a<b>c>\n%Q<a<b>c>",
        "replacement": "%q/b/\n%q{d{e}f}\n%/b/\n%Q/b/\n%{d{e}f}\n%Q{d{e}f}"
      },
      {
        "syntax": "math-assignment",
        "insert": "x += 1\nx -= 1\nx *= 1\nx /= 1\nx **= 1",
        "replacement": "x+= 2\nx -= 1\nx *= 1\nx /= 1\nx **= 1"
      },
      {
        "syntax": "conditional-assignment",
        "insert": "x ||= 5",
        "replacement": "x &&= 7"
      },
      {
        "syntax": "multiple-assignments",
        "insert": "x, y, z = [10, 20, 30]",
        "replacement": "x, *y = [10, 20, 30]"
      },
      {
        "syntax": "pseudo-variables",
        "insert": "nil\nself\nfalse\ntrue",
        "replacement": "self\nNIL\nTRUE\nFALSE"
      },
      {
        "syntax": "subshell",
        "insert": "`ls -la`",
        "replacement": "`git status`"
      },
      {
        "syntax": "hash",
        "insert": "{ :key1 => \"value\", :key2 => 1, \"key3\" => false, :\"symbol_key\" => 10 }",
        "replacement": "{ key1: \"changed value\", key2: 2, key3: true }"
      },
      {
        "syntax": "boolean-operator",
        "insert": "a || b",
        "replacement": "a && b"
      },
      {
        "syntax": "relational-operator",
        "insert": "x == y\nx != y\nx === y",
        "replacement": "x <=> y\nx =~ y\nx =! y"
      },
      {
        "syntax": "comparision-operator",
        "insert": "x < y\na > b",
        "replacement": "x <= y\na >= b"
      },
      {
        "syntax": "bitwise-operator",
        "insert": "a | b\na >> b\na ^ b",
        "replacement": "a & b\na << b"
      },
      {
        "syntax": "ternary",
        "insert": "foo ? case1 : case2",
        "replacement": "bar ? a : b"
      },
      {
        "syntax": "method-declaration",
        "insert": "def foo\nend",
        "replacement": "def bar(a)\n  baz\nend"
      },
      {
        "syntax": "method-declaration-params",
        "template": "def foo{0}\nend",
        "insert": "(a)",
        "replacement": "(a, b, c)"
      },
      {
        "syntax": "method-declaration-required-keyword-param",
        "insert": "def foo()\nend",
        "replacement": "def foo(name:)\nend"
      },
      {
        "syntax": "method-declaration-keyword-param",
        "insert": "def foo()\nend",
        "replacement": "def foo(name: nil)\nend"
      },
      {
        "syntax": "method-declaration-param-default",
        "insert": "def foo()\nend",
        "replacement": "def foo(name = nil)\nend"
      },
      {
        "syntax": "method-declaration-unnamed-param",
        "insert": "def foo(name)\nend",
        "replacement": "def foo(name, **)\nend"
      },
      {
        "syntax": "method-invocation",
        "insert": "print\nfoo.bar\nbar",
        "replacement": "print(\"hello world\")\nfoo.bar()\nbar 2, 3\nbar(2, 3)"
      },
      {
        "syntax": "method-calls",
        "insert": "x.foo()",
        "replacement": "bar()"
      },
      {
        "syntax": "method-calls-keyword-args",
        "insert": "foo(bar: true)",
        "replacement": "foo(bar: true, baz: 1)"
      },
      {
        "syntax": "method-calls-hash-args",
        "insert": "foo(:bar => true)",
        "replacement": "foo(:bar => true, :baz => 1)"
      },
      {
        "syntax": "class",
        "insert": "class Foo < Super\n  def test; end\nend",
        "replacement": "class Foo\n  def test; end\nend"
      },
      {
        "syntax": "module",
        "insert": "module Foo\nend",
        "replacement": "module Foo\n  def bar\n  end\nend"
      },
      {
        "syntax": "return",
        "insert": "return foo",
        "replacement": "return"
      },
      {
        "syntax": "yield",
        "insert": "yield foo",
        "replacement": "yield"
      },
      {
        "syntax": "while",
        "insert": "while foo do\nend\nfoo while run",
        "replacement": "while foo\n  bar\nend"
      },
      {
        "syntax": "until",
        "insert": "until foo do\nend\nfoo until done",
        "replacement": "until foo\n  bar\nend"
      },
      {
        "syntax": "if",
        "insert": "if foo\n  bar\nelsif quux\n  baz\nelse\n  bat\nend",
        "replacement": "if x\nend\nif y then\nend"
      },
      {
        "syntax": "unless",
        "insert": "unless foo\n  bar\nelse\n  bat\nend",
        "replacement": "unless x\nend\nunless y then\nend"
      },
      {
        "syntax": "if-unless-modifiers",
        "insert": "print unless foo",
        "replacement": "print if foo"
      },
      {
        "syntax": "and-or",
        "insert": "foo and bar",
        "replacement": "foo or bar\na or b and c"
      },
      {
        "syntax": "regex",
        "insert": "/^(foo|bar[^_])$/i",
        "replacement": "%r/a/\n%r<a<b>c>"
      },
      {
        "syntax": "array",
        "insert": "[ 1, 2, 3]",
        "replacement": "['a', 'b', 'c']"
      },
      {
        "syntax": "percent-array",
        "insert": "%w(one two)",
        "replacement": "%W(one #{b} three)"
      },
      {
        "syntax": "lambda-dash-rocket",
        "insert": "-> (a, b, c) {\n  1\n  2\n}",
        "replacement": "-> { foo }"
      },
      {
        "syntax": "lambda",
        "insert": "lambda { foo }",
        "replacement": "lambda { |x| x + 1 }"
      },
      {
        "syntax": "for",
        "insert": "for x in y\n  f\nend",
        "replacement": "for i in [1,2,3] do\n  print i\nend"
      },
      {
        "syntax": "element-reference",
        "insert": "foo[bar]\nfoo[:bar]\nfoo[bar] = 1",
        "replacement": "x[\"b\"]\nx[:\"c\"]"
      },
      {
        "syntax": "begin",
        "template": "def foo\n{0}end",
        "insert": "begin\nend\n",
        "replacement": "begin\n  puts 'hi'\nend\n"
      },
      {
        "syntax": "else",
        "template": "begin\n  foo()\n{0}end",
        "insert": "else\n",
        "replacement": "else\n  bar()\n"
      },
      {
        "syntax": "elsif",
        "template": "if bar\n  foo()\n{0}end",
        "insert": "elsif baz\n",
        "replacement": "elsif baz\n  qoz()\n"
      },
      {
        "syntax": "ensure",
        "template": "begin\n  foo\n{0}end",
        "insert": "ensure\n",
        "replacement": "ensure\n  bar\n"
      },
      {
        "syntax": "rescue",
        "template": "begin\n  foo\n{0}end",
        "insert": "rescue x\n",
        "replacement": "rescue x\n  bar\n"
      },
      {
        "syntax": "rescue-empty",
        "insert": "begin\n  foo\nrescue\nend",
        "replacement": "begin\n  foo\nrescue\n  bar\nend"
      },
      {
        "syntax": "rescue-last-ex",
        "insert": "begin\n  foo\nrescue Error => x\nend",
        "replacement": "begin\n  foo\nrescue Error => x\n  bar\nend"
      },
      {
        "syntax": "rescue-modifier",
        "insert": "foo rescue nil",
        "replacement": "foo rescue false"
      },
      {
        "syntax": "rescue-modifier2",
        "insert": "foo rescue nil",
        "replacement": "bar rescue nil"
      },
      {
        "syntax": "when",
        "template": "case foo\n{0}end",
        "insert": "when bar\n",
        "replacement": "when bar\n  baz\n"
      },
      {
        "syntax": "when-else",
        "template": "case foo\nwhen bar\n  baz\n{0}end",
        "insert": "else\n",
        "replacement": "else\n  qoz\n"
      },
      {
        "syntax": "begin-block",
        "insert": "BEGIN {\n foo\n}",
        "replacement": "foo\nBEGIN {\n bar\n}"
      },
      {
        "syntax": "end-block",
        "insert": "END {\n foo\n}",
        "replacement": "foo\nEND {\n bar\n}"
      }
    ]
  }
]
