[
  {
    "language": "ruby",
    "fileExt": ".rb",
    "repoUrl": "https://github.com/diff-fixtures/ruby.git",
    "syntaxes": [
      {
        "syntax": "assignment",
        "insert": "x = 0",
        "replacement": "x = 1"
      },
      {
        "syntax": "comment",
        "insert": "# This is a comment",
        "replacement": "=begin\nThis is a multiline\ncomment\n=end"
      },
      {
        "syntax": "number",
        "insert": "1234\n1_234\n0d1_234\n0xa_bcd_ef0_123_456_789\n0o1234567\n0b1_0\n1.234_5e678_90\n",
        "replacement": "1235\n1_235\n0d1_235\n0xa_bcd_ef0_123_456_788\n0o1234576\n0b1_1\n1.234_5e678_91\n"
      },
      {
        "syntax": "symbol",
        "insert": ":foo\n:'foo'\n:\"foo\"",
        "replacement": ":bar\n:'bar'\n:\"bar\""
      },
      {
        "syntax": "string",
        "insert": "''\n'foo with \"bar\"'",
        "replacement": "\"\"\n\"bar with 'foo'\""
      },
      {
        "syntax": "interpolation",
        "insert": ":\"foo #{bar}\"\n\"foo #{bar}\"",
        "replacement": ":\"bar #{foo}\"\n\"bar #{foo}\""
      },
      {
        "syntax": "delimiter",
        "insert": "%q#a#\n%q<a<b>c>\n%#a#\n%Q#a#\n%<a<b>c>\n%Q<a<b>c>",
        "replacement": "%q/b/\n%q{d{e}f}\n%/b/\n%Q/b/\n%{d{e}f}\n%Q{d{e}f}"
      },
      {
        "syntax": "math-assignment",
        "insert": "x += 1\nx -= 1\nx *= 1\nx /= 1\nx **= 1",
        "replacement": "x+= 2\nx -= 1\nx *= 1\nx /= 1\nx **= 1"
      },
      {
        "syntax": "conditional-assignment",
        "insert": "x ||= 5",
        "replacement": "x &&= 7"
      },
      {
        "syntax": "multiple-assignments",
        "insert": "x, y, z = 10, 20, 30",
        "replacement": "x, y = aVariable, 40"
      },
      {
        "syntax": "pseudo-variables",
        "insert": "nil\nself\nfalse\ntrue",
        "replacement": "self\nNIL\nTRUE\nFALSE"
      },
      {
        "syntax": "subshell",
        "insert": "`ls -la`",
        "replacement": "`git status`"
      },
      {
        "syntax": "hash",
        "insert": "{ :key1 => \"value\", :key2 => 1, \"key3\" => false, :\"symbol_key\" => 10 }",
        "replacement": "{ key1: \"changed value\", key2: 2, key3: true }"
      },
      {
        "syntax": "boolean-operator",
        "insert": "a || b",
        "replacement": "a && b"
      },
      {
        "syntax": "relational-operator",
        "insert": "x == y\nx != y\nx === y",
        "replacement": "x <=> y\nx =~ y\nx =! y"
      },
      {
        "syntax": "comparision-operator",
        "insert": "x < y\na > b",
        "replacement": "x <= y\na >= b"
      },
      {
        "syntax": "bitwise-operator",
        "insert": "a | b\na >> b\na ^ b",
        "replacement": "a & b\na << b"
      },
      {
        "syntax": "ternary",
        "insert": "condition ? case1 : case2",
        "replacement": "if condition then case 1 else case2"
      },
      {
        "syntax": "method-invocation",
        "insert": "print\nfoo.bar\nbar",
        "replacement": "print(\"hello world\")\nfoo.bar()\nbar 2, 3\nbar(2, 3)"
      },
      {
        "syntax": "case-statement",
        "insert": "case foo\nwhen bar\nend",
        "replacement": "case foo\nwhen bar\nelse\nend"
      },
      {
        "syntax": "class",
        "insert": "class Foo < Super\n  def test; end\nend",
        "replacement": "class Foo\n  def test; end\nend"
      },
      {
        "syntax": "module",
        "insert": "module Foo\n  class Bar\n    def self.test; end\nend\nend",
        "replacement": "class Bar::Foo\nend"
      },
      {
        "syntax": "return",
        "insert": "return foo",
        "replacement": "return"
      },
      {
        "syntax": "yield",
        "insert": "yield foo",
        "replacement": "yield"
      },
      {
        "syntax": "while",
        "insert": "while foo do\nend\nfoo while run",
        "replacement": "while foo\n  bar\nend"
      },
      {
        "syntax": "until",
        "insert": "until foo do\nend\nfoo until done",
        "replacement": "until foo\n  bar\nend"
      },
      {
        "syntax": "if",
        "insert": "if foo\n  bar\nelsif quux\n  baz\nelse\n  bat\nend",
        "replacement": "if x\nend\nif y then\nend"
      },
      {
        "syntax": "unless",
        "insert": "unless foo\n  bar\nelse\n  bat\nend",
        "replacement": "unless x\nend\nunless y then\nend"
      },
      {
        "syntax": "if-unless-modifiers",
        "insert": "print unless foo",
        "replacement": "print if foo"
      },
      {
        "syntax": "and-or",
        "insert": "foo and bar",
        "replacement": "foo or bar\na or b and c"
      },
      {
        "syntax": "regex",
        "insert": "/^(foo|bar[^_])$/i",
        "replacement": "%r/a/\n%r<a<b>c>"
      },
      {
        "syntax": "array",
        "insert": "[ 1, 2, 3]",
        "replacement": "['a', 'b', 'c']"
      },
      {
        "syntax": "percent-array",
        "insert": "%w(one two)",
        "replacement": "%W(one #{b} three)"
      },
      {
        "syntax": "lambda-dash-rocket",
        "insert": "-> (a, b, c) {\n  1\n  2\n}",
        "replacement": "-> { foo }"
      },
      {
        "syntax": "lambda",
        "insert": "lambda { foo }",
        "replacement": "lambda { |x| x + 1 }"
      },
      {
        "syntax": "for",
        "insert": "for x in y\n  f\nend",
        "replacement": "for i in [1,2,3] do\n  print i\nend"
      },
      {
        "syntax": "element-reference",
        "insert": "foo[bar]\nfoo[:bar]\nfoo[bar] = 1",
        "replacement": "x[\"b\"]\nx[:\"c\"]"
      },
      {
        "syntax": "begin",
        "insert": "begin\nend",
        "replacement": "begin\n  foo()\nend"
      },
      {
        "syntax": "begin-else",
        "insert": "begin\n  foo()\nend",
        "replacement": "begin\n  foo()\nelse\n  bar()\nend"
      },
      {
        "syntax": "else",
        "insert": "begin\n  foo()\nelse\nend",
        "replacement": "begin\n  foo()\nelse\n  bar()\nend"
      },
      {
        "syntax": "if-elsif",
        "insert": "if bar\n  foo()\nend",
        "replacement": "if bar\n  foo()\nelsif baz\n  qoz()\nend"
      },
      {
        "syntax": "elsif",
        "insert": "if bar\n  foo()\nelsif baz\nend",
        "replacement": "if bar\n  foo()\nelsif baz\n  qoz()\nend"
      }
    ]
  }
]
