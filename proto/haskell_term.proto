// This file was generated by proto-gen. Do not edit by hand.
syntax = "proto3";

package github.semantic.haskellterm;

import "types.proto";

option java_package = "com.github.semantic.haskellterm";
option go_package = "github.com/semantic/haskellterm;haskell";

message HaskellTerm {
  HaskellSyntax syntax = 1;
}

message HaskellSyntax {
  oneof syntax {
    Comment comment = 1;
    Constructor constructor = 2;
    Datatype datatype = 3;
    Function function = 4;
    Array array = 5;
    Character character = 6;
    Float float = 7;
    Integer integer = 8;
    TextElement textElement = 9;
    Tuple tuple = 10;
    If if = 11;
    Match match = 12;
    Pattern pattern = 13;
    AllConstructors allConstructors = 14;
    AnnotatedTypeVariable annotatedTypeVariable = 15;
    App app = 16;
    ArithmeticSequence arithmeticSequence = 17;
    AsPattern asPattern = 18;
    BindPattern bindPattern = 19;
    CaseGuardPattern caseGuardPattern = 20;
    Class class = 21;
    ConstructorIdentifier constructorIdentifier = 22;
    ConstructorOperator constructorOperator = 23;
    ConstructorPattern constructorPattern = 24;
    ConstructorSymbol constructorSymbol = 25;
    Context context = 26;
    ContextAlt contextAlt = 27;
    CPPDirective cPPDirective = 28;
    DefaultDeclaration defaultDeclaration = 29;
    DefaultSignature defaultSignature = 30;
    Deriving deriving = 31;
    Do do = 32;
    Empty empty = 33;
    Error error = 34;
    EqualityConstraint equalityConstraint = 35;
    Export export = 36;
    ExpressionTypeSignature expressionTypeSignature = 37;
    Field field = 38;
    FieldBind fieldBind = 39;
    FieldPattern fieldPattern = 40;
    FixityAlt fixityAlt = 41;
    FunctionalDependency functionalDependency = 42;
    FunctionConstructor functionConstructor = 43;
    FunctionGuardPattern functionGuardPattern = 44;
    FunctionType functionType = 45;
    GADT gADT = 46;
    GADTConstructor gADTConstructor = 47;
    Generator generator = 48;
    Guard guard = 49;
    HiddenImport hiddenImport = 50;
    Identifier identifier = 51;
    InfixConstructorIdentifier infixConstructorIdentifier = 52;
    InfixOperatorApp infixOperatorApp = 53;
    InfixVariableIdentifier infixVariableIdentifier = 54;
    ImplicitParameterIdentifier implicitParameterIdentifier = 55;
    Import import = 56;
    ImportAlias importAlias = 57;
    ImportDeclaration importDeclaration = 58;
    InfixDataConstructor infixDataConstructor = 59;
    InfixOperatorPattern infixOperatorPattern = 60;
    Instance instance = 61;
    IrrefutablePattern irrefutablePattern = 62;
    Kind kind = 63;
    KindFunctionType kindFunctionType = 64;
    KindListType kindListType = 65;
    KindParenthesizedConstructor kindParenthesizedConstructor = 66;
    KindSignature kindSignature = 67;
    KindTupleType kindTupleType = 68;
    LabeledConstruction labeledConstruction = 69;
    LabeledPattern labeledPattern = 70;
    LabeledUpdate labeledUpdate = 71;
    Lambda lambda = 72;
    LambdaCase lambdaCase = 73;
    LeftOperatorSection leftOperatorSection = 74;
    Let let = 75;
    ListComprehension listComprehension = 76;
    ListConstructor listConstructor = 77;
    ListPattern listPattern = 78;
    Module module = 79;
    ModuleExport moduleExport = 80;
    ModuleIdentifier moduleIdentifier = 81;
    NamedFieldPun namedFieldPun = 82;
    NegativeLiteral negativeLiteral = 83;
    NewType newType = 84;
    PatternGuard patternGuard = 85;
    Pragma pragma = 86;
    PrefixNegation prefixNegation = 87;
    PrimitiveConstructorIdentifier primitiveConstructorIdentifier = 88;
    PrimitiveVariableIdentifier primitiveVariableIdentifier = 89;
    PromotedTypeOperator promotedTypeOperator = 90;
    QualifiedConstructorIdentifier qualifiedConstructorIdentifier = 91;
    QualifiedInfixVariableIdentifier qualifiedInfixVariableIdentifier = 92;
    QualifiedModuleIdentifier qualifiedModuleIdentifier = 93;
    QualifiedImportDeclaration qualifiedImportDeclaration = 94;
    QualifiedTypeClassIdentifier qualifiedTypeClassIdentifier = 95;
    QualifiedTypeConstructorIdentifier qualifiedTypeConstructorIdentifier = 96;
    QualifiedVariableIdentifier qualifiedVariableIdentifier = 97;
    QuasiQuotation quasiQuotation = 98;
    QuasiQuotationDeclaration quasiQuotationDeclaration = 99;
    QuasiQuotationExpression quasiQuotationExpression = 100;
    QuasiQuotationExpressionBody quasiQuotationExpressionBody = 101;
    QuasiQuotationPattern quasiQuotationPattern = 102;
    QuasiQuotationQuoter quasiQuotationQuoter = 103;
    QuasiQuotationType quasiQuotationType = 104;
    QuotedName quotedName = 105;
    RecordDataConstructor recordDataConstructor = 106;
    RecordWildCards recordWildCards = 107;
    RightOperatorSection rightOperatorSection = 108;
    ScopedTypeVariables scopedTypeVariables = 109;
    Splice splice = 110;
    StandaloneDerivingInstance standaloneDerivingInstance = 111;
    Star star = 112;
    StrictPattern strictPattern = 113;
    StrictType strictType = 114;
    StrictTypeVariable strictTypeVariable = 115;
    TupleConstructor tupleConstructor = 116;
    TupleExpression tupleExpression = 117;
    TuplePattern tuplePattern = 118;
    Type type = 119;
    TypeApp typeApp = 120;
    TypeClass typeClass = 121;
    TypeClassIdentifier typeClassIdentifier = 122;
    TypeClassInstance typeClassInstance = 123;
    TypeConstructorExport typeConstructorExport = 124;
    TypeConstructorIdentifier typeConstructorIdentifier = 125;
    TypeFamily typeFamily = 126;
    TypeInstance typeInstance = 127;
    TypeOperator typeOperator = 128;
    TypePattern typePattern = 129;
    TypeSignature typeSignature = 130;
    TypeSynonym typeSynonym = 131;
    TypeVariableIdentifier typeVariableIdentifier = 132;
    UnitConstructor unitConstructor = 133;
    VariableIdentifier variableIdentifier = 134;
    VariableOperator variableOperator = 135;
    VariableSymbol variableSymbol = 136;
    ViewPattern viewPattern = 137;
    Wildcard wildcard = 138;
    TypeParameters typeParameters = 139;
    List list = 140;
  }
}

message Comment {
  string commentContent = 1;
}

message Constructor {
  repeated HaskellTerm constructorContext = 1;
  HaskellTerm constructorName = 2;
  HaskellTerm constructorFields = 3;
}

message Datatype {
  HaskellTerm datatypeContext = 1;
  HaskellTerm datatypeName = 2;
  repeated HaskellTerm datatypeConstructors = 3;
  HaskellTerm datatypeDeriving = 4;
}

message Function {
  repeated HaskellTerm functionContext = 1;
  HaskellTerm functionName = 2;
  repeated HaskellTerm functionParameters = 3;
  HaskellTerm functionBody = 4;
}

message Array {
  repeated HaskellTerm arrayElements = 1;
}

message Character {
  string characterContent = 1;
}

message Float {
  string floatContent = 1;
}

message Integer {
  string integerContent = 1;
}

message TextElement {
  string textElementContent = 1;
}

message Tuple {
  repeated HaskellTerm tupleContents = 1;
}

message If {
  HaskellTerm ifCondition = 1;
  HaskellTerm ifThenBody = 2;
  HaskellTerm ifElseBody = 3;
}

message Match {
  HaskellTerm matchSubject = 1;
  HaskellTerm matchPatterns = 2;
}

message Pattern {
  HaskellTerm value = 1;
  HaskellTerm patternBody = 2;
}

message AllConstructors { }

message AnnotatedTypeVariable {
  HaskellTerm annotatedTypeVariableIdentifier = 1;
  HaskellTerm annotatedTypeVariableannotation = 2;
}

message App {
  HaskellTerm appLeft = 1;
  HaskellTerm appLeftTypeApp = 2;
  HaskellTerm appRight = 3;
}

message ArithmeticSequence {
  HaskellTerm from = 1;
  repeated HaskellTerm next = 2;
  repeated HaskellTerm to = 3;
}

message AsPattern {
  HaskellTerm asPatternLeft = 1;
  HaskellTerm asPatternRight = 2;
}

message BindPattern {
  repeated HaskellTerm bindPatternLeft = 1;
  HaskellTerm bindPatternRight = 2;
}

message CaseGuardPattern {
  repeated HaskellTerm values = 1;
}

message Class {
  repeated HaskellTerm classContent = 1;
}

message ConstructorIdentifier {
  bytes name = 1;
}

message ConstructorOperator {
  HaskellTerm value = 1;
}

message ConstructorPattern {
  HaskellTerm value = 1;
}

message ConstructorSymbol {
  bytes constructorSymbolName = 1;
}

message Context {
  repeated HaskellTerm contextTerms = 1;
  HaskellTerm contextSubject = 2;
}

message ContextAlt {
  HaskellTerm value = 1;
}

message CPPDirective {
  string value = 1;
}

message DefaultDeclaration {
  repeated HaskellTerm defaultDeclarationContent = 1;
}

message DefaultSignature {
  repeated HaskellTerm defaultSignatureName = 1;
  repeated HaskellTerm defaultSignatureContext = 2;
  HaskellTerm defaultSignatureContent = 3;
}

message Deriving {
  repeated HaskellTerm values = 1;
}

message Do {
  repeated HaskellTerm values = 1;
}

message Empty { }

message Error {
  repeated ErrorSite errorCallStack = 1;
  repeated string errorExpected = 2;
  string errorActual = 3;
  repeated HaskellTerm errorChildren = 4;
}

message EqualityConstraint {
  HaskellTerm equalityConstraintLeft = 1;
  HaskellTerm equalityConstraintRight = 2;
}

message Export {
  HaskellTerm exportContent = 1;
}

message ExpressionTypeSignature {
  repeated HaskellTerm expressionTypeSignatureName = 1;
  repeated HaskellTerm expressionTypeSignatureContext = 2;
  HaskellTerm expressionTypeSignatureContent = 3;
}

message Field {
  HaskellTerm fieldName = 1;
  HaskellTerm fieldBody = 2;
}

message FieldBind {
  HaskellTerm fieldBindLeft = 1;
  HaskellTerm fieldBindRight = 2;
}

message FieldPattern {
  HaskellTerm fieldPatternLeft = 1;
  HaskellTerm fieldPatternRight = 2;
}

message FixityAlt {
  HaskellTerm fixityPrecedence = 1;
  repeated HaskellTerm fixityIdentifier = 2;
}

message FunctionalDependency {
  HaskellTerm functionalDependencyContent = 1;
}

message FunctionConstructor { }

message FunctionGuardPattern {
  repeated HaskellTerm values = 1;
}

message FunctionType {
  HaskellTerm functionTypeLeft = 1;
  HaskellTerm functionTypeRight = 2;
}

message GADT {
  HaskellTerm gadtContext = 1;
  HaskellTerm gadtName = 2;
  HaskellTerm gadtConstructors = 3;
}

message GADTConstructor {
  HaskellTerm gadtConstructorContext = 1;
  HaskellTerm gadtConstructorName = 2;
  HaskellTerm gadtConstructorTypeSignature = 3;
}

message Generator {
  HaskellTerm generatorValue = 1;
  HaskellTerm generatorSource = 2;
}

message Guard {
  HaskellTerm value = 1;
}

message HiddenImport {
  HaskellTerm hiddenimportContent = 1;
}

message Identifier {
  bytes name = 1;
}

message InfixConstructorIdentifier {
  bytes name = 1;
}

message InfixOperatorApp {
  HaskellTerm infixOperatorAppLeft = 1;
  HaskellTerm infixOperatorAppLeftTypeApp = 2;
  HaskellTerm infixOperatorAppOperator = 3;
  HaskellTerm infixOperatorAppRight = 4;
}

message InfixVariableIdentifier {
  bytes name = 1;
}

message ImplicitParameterIdentifier {
  bytes name = 1;
}

message Import {
  HaskellTerm importContent = 1;
}

message ImportAlias {
  HaskellTerm importAliasSource = 1;
  HaskellTerm importAliasName = 2;
}

message ImportDeclaration {
  HaskellTerm importPackageQualifiedContent = 1;
  HaskellTerm importModule = 2;
  repeated HaskellTerm importSpec = 3;
}

message InfixDataConstructor {
  repeated HaskellTerm infixDataConstructorContext = 1;
  HaskellTerm infixDataConstructorLeft = 2;
  HaskellTerm infixDataConstructorOperator = 3;
  HaskellTerm infixDataConstructorRight = 4;
}

message InfixOperatorPattern {
  HaskellTerm infixOperatorPatternLeft = 1;
  HaskellTerm infixOperatorPatternOperator = 2;
  HaskellTerm infixOperatorPatternRight = 3;
}

message Instance {
  HaskellTerm value = 1;
}

message IrrefutablePattern {
  HaskellTerm value = 1;
}

message Kind {
  HaskellTerm kindKind = 1;
}

message KindFunctionType {
  HaskellTerm kindFunctionTypeLeft = 1;
  HaskellTerm kindFunctionTypeRight = 2;
}

message KindListType {
  HaskellTerm kindListTypeKind = 1;
}

message KindParenthesizedConstructor {
  HaskellTerm kindParenthesizedConstructorContent = 1;
}

message KindSignature {
  HaskellTerm kindSignatureContent = 1;
}

message KindTupleType {
  repeated HaskellTerm kindTupleType = 1;
}

message LabeledConstruction {
  HaskellTerm labeledConstructionConstructor = 1;
  repeated HaskellTerm labeledConstructionFields = 2;
}

message LabeledPattern {
  HaskellTerm value = 1;
}

message LabeledUpdate {
  repeated HaskellTerm values = 1;
}

message Lambda {
  HaskellTerm lambdaHead = 1;
  HaskellTerm lambdaBody = 2;
}

message LambdaCase {
  repeated HaskellTerm values = 1;
}

message LeftOperatorSection {
  HaskellTerm lhs = 1;
  HaskellTerm rhs = 2;
}

message Let {
  repeated HaskellTerm letStatements = 1;
  HaskellTerm letInClause = 2;
}

message ListComprehension {
  HaskellTerm comprehensionValue = 1;
  repeated HaskellTerm comprehensionSource = 2;
}

message ListConstructor { }

message ListPattern {
  HaskellTerm value = 1;
}

message Module {
  repeated HaskellTerm moduleContext = 1;
  HaskellTerm moduleIdentifier = 2;
  repeated HaskellTerm moduleExports = 3;
  HaskellTerm moduleStatements = 4;
}

message ModuleExport {
  HaskellTerm moduleExportContent = 1;
}

message ModuleIdentifier {
  bytes name = 1;
}

message NamedFieldPun {
  HaskellTerm value = 1;
}

message NegativeLiteral {
  HaskellTerm value = 1;
}

message NewType {
  repeated HaskellTerm newTypeContext = 1;
  HaskellTerm newTypeLeft = 2;
  HaskellTerm newTypeRight = 3;
  HaskellTerm newTypeDeriving = 4;
}

message PatternGuard {
  HaskellTerm patternGuardPattern = 1;
  HaskellTerm patternGuardExpression = 2;
}

message Pragma {
  string value = 1;
}

message PrefixNegation {
  HaskellTerm value = 1;
}

message PrimitiveConstructorIdentifier {
  bytes name = 1;
}

message PrimitiveVariableIdentifier {
  bytes name = 1;
}

message PromotedTypeOperator {
  HaskellTerm value = 1;
}

message QualifiedConstructorIdentifier {
  repeated HaskellTerm values = 1;
}

message QualifiedInfixVariableIdentifier {
  repeated HaskellTerm values = 1;
}

message QualifiedModuleIdentifier {
  repeated HaskellTerm values = 1;
}

message QualifiedImportDeclaration {
  HaskellTerm qualifiedImportPackageQualifiedContent = 1;
  HaskellTerm qualifiedImportModule = 2;
  repeated HaskellTerm qualifiedImportSpec = 3;
}

message QualifiedTypeClassIdentifier {
  repeated HaskellTerm values = 1;
}

message QualifiedTypeConstructorIdentifier {
  repeated HaskellTerm values = 1;
}

message QualifiedVariableIdentifier {
  repeated HaskellTerm values = 1;
}

message QuasiQuotation {
  HaskellTerm quasiQuotationHead = 1;
  HaskellTerm quasiQuotationBody = 2;
}

message QuasiQuotationDeclaration { }

message QuasiQuotationExpression { }

message QuasiQuotationExpressionBody {
  bytes name = 1;
}

message QuasiQuotationPattern { }

message QuasiQuotationQuoter {
  bytes name = 1;
}

message QuasiQuotationType { }

message QuotedName {
  HaskellTerm quotedNameContent = 1;
}

message RecordDataConstructor {
  repeated HaskellTerm recordDataConstructorContext = 1;
  HaskellTerm recordDataConstructorName = 2;
  HaskellTerm recordDataConstructorFields = 3;
}

message RecordWildCards { }

message RightOperatorSection {
  HaskellTerm lhs = 1;
  HaskellTerm rhs = 2;
}

message ScopedTypeVariables {
  HaskellTerm scopedTypeVariablesContent = 1;
}

message Splice {
  HaskellTerm value = 1;
}

message StandaloneDerivingInstance {
  repeated HaskellTerm standaloneDerivingInstanceContext = 1;
  HaskellTerm standaloneDerivingInstanceClass = 2;
  HaskellTerm standaloneDerivingInstanceInstance = 3;
}

message Star { }

message StrictPattern {
  HaskellTerm value = 1;
}

message StrictType {
  HaskellTerm strictTypeIdentifier = 1;
  HaskellTerm strictTypeParameters = 2;
}

message StrictTypeVariable {
  HaskellTerm value = 1;
}

message TupleConstructor {
  int64 tupleConstructorArity = 1;
}

message TupleExpression {
  repeated HaskellTerm values = 1;
}

message TuplePattern {
  repeated HaskellTerm value = 1;
}

message Type {
  HaskellTerm typeIdentifier = 1;
  HaskellTerm typeParameters = 2;
  HaskellTerm typeKindSignature = 3;
}

message TypeApp {
  HaskellTerm typeAppType = 1;
}

message TypeClass {
  HaskellTerm typeClassContext = 1;
  HaskellTerm typeClassIdentifier = 2;
  repeated HaskellTerm typeClassParameters = 3;
  HaskellTerm typeClassBody = 4;
}

message TypeClassIdentifier {
  bytes name = 1;
}

message TypeClassInstance {
  repeated HaskellTerm typeClassInstanceContext = 1;
  HaskellTerm typeClassInstanceIdentifier = 2;
  HaskellTerm typeClassInstanceInstance = 3;
  HaskellTerm typeClassInstanceBody = 4;
}

message TypeConstructorExport {
  HaskellTerm typeConstructorExportContent = 1;
}

message TypeConstructorIdentifier {
  bytes name = 1;
}

message TypeFamily {
  HaskellTerm typeFamilyIdentifier = 1;
  repeated HaskellTerm typeFamilyParameters = 2;
  HaskellTerm typeFamilySignature = 3;
  HaskellTerm typeFamilyBody = 4;
}

message TypeInstance {
  HaskellTerm typeInstanceType = 1;
  HaskellTerm typeInstanceBody = 2;
}

message TypeOperator {
  bytes name = 1;
}

message TypePattern {
  HaskellTerm typePatternContent = 1;
}

message TypeSignature {
  repeated HaskellTerm typeSignatureName = 1;
  repeated HaskellTerm typeSignatureContext = 2;
  HaskellTerm typeSignatureContent = 3;
}

message TypeSynonym {
  HaskellTerm typeSynonymLeft = 1;
  repeated HaskellTerm typeSynonymContext = 2;
  HaskellTerm typeSynonymRight = 3;
}

message TypeVariableIdentifier {
  bytes name = 1;
}

message UnitConstructor { }

message VariableIdentifier {
  bytes name = 1;
}

message VariableOperator {
  HaskellTerm value = 1;
}

message VariableSymbol {
  bytes variableSymbolName = 1;
}

message ViewPattern {
  HaskellTerm viewPatternLeft = 1;
  HaskellTerm viewPatternRight = 2;
}

message Wildcard { }

message TypeParameters {
  repeated HaskellTerm terms = 1;
}

message List {
  repeated HaskellTerm listContent = 1;
}
