[
  {
    "repoUrl": "https://github.com/joshvera/go.git",
    "language": "go",
    "fileExt": ".go",
    "templateText": "package main\n",
    "syntaxes": [
      {
        "syntax": "imports",
        "repoFilePath": "imports",
        "insert": "import \"net/http\"\nimport . \"some/dsl\"\nimport alias \"some/package\"",
        "testCaseFilePath": "test/corpus/diff-summaries/go/imports.json",
        "replacement": "import \"foo/bar\"\nimport . \"types/dsl\"\nimport alias \"awesome/packages\""
      },
      {
        "syntax": "int-literal",
        "insert": "const (\na = 1, b = 2, c = 3\n)",
        "replacement": "const (\na = 4, b = 5, c = 6\n)"
      },
      {
        "syntax": "assignment",
        "insert": "var foo int = 42",
        "replacement": "var bar string = \"hello\""
      },
      {
        "syntax": "call-expressions.go",
        "insert": "a()",
        "replacement": "b()"
      },
      {
        "syntax": "function-literal",
        "insert": "const s1 = func(s string) (int, int) {\nreturn 1, 2\n}",
        "replacement": "const s1 = func(b int) (string, string) {\nreturn 1, 2\n}"
      },
      {
        "syntax": "const-declarations",
        "insert": "const zero = 0",
        "replacement": "const one, two = 1, 2"
      },
      {
        "syntax": "var-declarations",
        "insert": "var zero = 0",
        "replacement": "var one, two = 1, 2"
      },
      {
        "syntax": "var-declarations",
        "insert": "var zero = 0",
        "replacement": "var one, two = 1, 2"
      },
      {
        "syntax": "switch-statements",
        "insert": "switch { case x < y: f1()\ncase x < z: g()\ncase x == 4: h()\n}",
        "replacement": "switch { case a < b: f1()\ncase c < d: g()\ncase e == 4: f()\n}"
      },
      {
        "syntax": "for-statements",
        "insert": "for { case x < y: f1()\ncase x < z: g()\ncase x == 4: h()\n}",
        "replacement": "func main() { for { a() goto loop }\nloop: for i := 0; i < 5; i++\n{ a()\nbreak loop\n}\nloop2: for ; i < 10; i++ \n{ \na()\ncontinue loop2\n}\nfor ;; { a() continue }\nfor x := range y { a(x)\nbreak }\n}"
      },
      {
        "syntax": "function-declarations",
        "insert": "func f1() {}\nfunc f2(a int, b, c, d string) int {}\nfunc f2() (int, error) {}\nfunc f2() (result int, err error) {}",
        "replacement": "func fa() {}\nfunc fb(a int, b, c, d string) int {}\nfunc fc() (int, error) {}\nfunc fd() (result int, err error) {}"
      },
      {
        "syntax": "function-declarations",
        "repoFilePath": "function-declarations.go",
        "insert": "func f1() {}\nfunc f2(a int, b, c, d string) int {}\nfunc f2() (int, error) {}\nfunc f2() (result int, err error) {}",
        "replacement": "func fa() {}\nfunc fb(a int, b, c, d string) int {}\nfunc fc() (int, error) {}\nfunc fd() (result int, err error) {}"
      },
      {
        "syntax": "method-declarations",
        "insert": "func (self Person) Equals(other Person) bool {}",
        "replacement": "func (self Num) Equals(other Num) bool {}"
      },
      {
        "syntax": "type-declarations",
        "insert": "type a b\ntype (\n a b\n c d\n )",
        "replacement": "type a' b'\ntype (\n a' b'\n c' d'\n )"
      },
      {
        "syntax": "type-declarations",
        "insert": "type a b\ntype (\n a b\n c d\n )",
        "replacement": "type a' b'\ntype (\n a' b'\n c' d'\n )"
      },
      {
        "syntax": "const-with-implicit-values",
        "insert": "const (\n zero = iota\n one\n two\n )",
        "replacement": "const (\n a = iota\n b\n c\n )"
      },
      {
        "syntax": "const-with-implicit-values",
        "insert": "const (\n zero = iota\n one\n two\n )",
        "replacement": "const (\n a = iota\n b\n c\n )"
      },
      {
        "syntax": "constructors",
        "insert": "make(chan<- int)\nmake(chan<- int, (new - old))\nmake(chan<- int, 5, 10)\n new(map[string]string)",
        "replacement": "make(chan<- string)\nmake(chan<- string, (new - old))\nmake(chan<- string, 7, 11)\n new(map[int]int)"
      },
      {
        "syntax": "selector expressions",
        "insert": "a.b.c()",
        "replacement": "x.y.z()"
      },
      {
        "syntax": "indexing expressions",
        "insert": "a[1]\n b[:]\n c[1:]\n d[1:2]\n e[:2:3]\n f[1:2:3]",
        "replacement": "z[:2]\n y[:1]\n x[1:]\n d[1:2]\n e[:2:3]\n f[1:2:3]"
      }
      {
        "syntax": "type-assertion-expression",
        "insert": "x.(z.Person)",
        "replacement": "b.(c.Dog)"
      },
      {
        "syntax": "type-conversion-expression",
        "insert": "[]a.b(c.d)\n ([]a.b)(c.d)\n e.f(g)\n (e.f)(g)",
        "replacement": "[]x.y(z.e)\n ([]f.g)(h.i)\n j.k(l)\n (m.n)(o)"
      },
      {
        "syntax": "unary-expressions",
        "insert": "!<-a\n*foo()",
        "replacement": "!<-b\n*bar()"
      }
    ]
  }
]