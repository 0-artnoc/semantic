// This file was generated by proto-gen. Do not edit by hand.
syntax = "proto3";

package github.semantic.ruby_diffs;

import "types.proto";

option java_package = "com.github.semantic.ruby_diffs";
option go_package = "github.com/semantic/ruby_diffs;ruby";

message RubyDiff {
  oneof diff {
    Merge merge = 1;
    Delete delete = 2;
    Insert insert = 3;
    Replace replace = 4;
  }
  message Merge {
    RubySyntax syntax = 1;
  }
  message Delete {
    RubySyntax before = 1;
  }
  message Insert {
    RubySyntax after = 1;
  }
  message Replace {
    RubySyntax before = 1;
    RubySyntax after = 2;
  }
}

message Comment {
  string commentContent = 1;
}

message Function {
  repeated RubyDiff functionContext = 1;
  RubyDiff functionName = 2;
  repeated RubyDiff functionParameters = 3;
  RubyDiff functionBody = 4;
}

message Method {
  repeated RubyDiff methodContext = 1;
  RubyDiff methodReceiver = 2;
  RubyDiff methodName = 3;
  repeated RubyDiff methodParameters = 4;
  RubyDiff methodBody = 5;
}

message File { }

message Line { }

message Error {
  repeated ErrorSite errorCallStack = 1;
  repeated string errorExpected = 2;
  string errorActual = 3;
  repeated RubyDiff errorChildren = 4;
}

message And {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message BAnd {
  RubyDiff left = 1;
  RubyDiff right = 2;
}

message BOr {
  RubyDiff left = 1;
  RubyDiff right = 2;
}

message BXOr {
  RubyDiff left = 1;
  RubyDiff right = 2;
}

message Call {
  repeated RubyDiff callContext = 1;
  RubyDiff callFunction = 2;
  repeated RubyDiff callParams = 3;
  RubyDiff callBlock = 4;
}

message Comparison {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Complement {
  RubyDiff value = 1;
}

message DividedBy {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Enumeration {
  RubyDiff enumerationStart = 1;
  RubyDiff enumerationEnd = 2;
  RubyDiff enumerationStep = 3;
}

message Equal {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message FloorDivision {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message GreaterThan {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message GreaterThanEqual {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message LShift {
  RubyDiff left = 1;
  RubyDiff right = 2;
}

message LessThan {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message LessThanEqual {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Matches {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Member {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message MemberAccess {
  RubyDiff lhs = 1;
  bytes rhs = 2;
}

message Minus {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Modulo {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Negate {
  RubyDiff value = 1;
}

message Not {
  RubyDiff value = 1;
}

message NotMatches {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Or {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Plus {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Power {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message RShift {
  RubyDiff left = 1;
  RubyDiff right = 2;
}

message ScopeResolution {
  repeated RubyDiff scopes = 1;
}

message StrictEqual {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Subscript {
  RubyDiff lhs = 1;
  repeated RubyDiff rhs = 2;
}

message Times {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message This { }

message XOr {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Array {
  repeated RubyDiff arrayElements = 1;
}

message Boolean {
  bool booleanContent = 1;
}

message Complex {
  string value = 1;
}

message Float {
  string floatContent = 1;
}

message Hash {
  repeated RubyDiff hashElements = 1;
}

message Integer {
  string integerContent = 1;
}

message KeyValue {
  RubyDiff key = 1;
  RubyDiff value = 2;
}

message Null { }

message Rational {
  string value = 1;
}

message Regex {
  string regexContent = 1;
}

message String {
  repeated RubyDiff stringElements = 1;
}

message Symbol {
  repeated RubyDiff symbolElements = 1;
}

message TextElement {
  string textElementContent = 1;
}

message Class {
  RubyDiff classIdentifier = 1;
  repeated RubyDiff classSuperClass = 2;
  RubyDiff classBody = 3;
}

message Load {
  RubyDiff loadPath = 1;
  repeated RubyDiff loadWrap = 2;
}

message LowPrecedenceAnd {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message LowPrecedenceOr {
  RubyDiff lhs = 1;
  RubyDiff rhs = 2;
}

message Module {
  RubyDiff moduleIdentifier = 1;
  repeated RubyDiff moduleStatements = 2;
}

message Require {
  bool requireRelative = 1;
  RubyDiff requirePath = 2;
}

message Send {
  repeated RubyDiff sendReceiver = 1;
  repeated RubyDiff sendSelector = 2;
  repeated RubyDiff sendArgs = 3;
  repeated RubyDiff sendBlock = 4;
}

message Assignment {
  repeated RubyDiff assignmentContext = 1;
  RubyDiff assignmentTarget = 2;
  RubyDiff assignmentValue = 3;
}

message Break {
  RubyDiff value = 1;
}

message Catch {
  RubyDiff catchException = 1;
  RubyDiff catchBody = 2;
}

message Continue {
  RubyDiff value = 1;
}

message Else {
  RubyDiff elseCondition = 1;
  RubyDiff elseBody = 2;
}

message Finally {
  RubyDiff value = 1;
}

message ForEach {
  RubyDiff forEachBinding = 1;
  RubyDiff forEachSubject = 2;
  RubyDiff forEachBody = 3;
}

message If {
  RubyDiff ifCondition = 1;
  RubyDiff ifThenBody = 2;
  RubyDiff ifElseBody = 3;
}

message Match {
  RubyDiff matchSubject = 1;
  RubyDiff matchPatterns = 2;
}

message Pattern {
  RubyDiff value = 1;
  RubyDiff patternBody = 2;
}

message Retry {
  RubyDiff value = 1;
}

message Return {
  RubyDiff value = 1;
}

message ScopeEntry {
  repeated RubyDiff terms = 1;
}

message ScopeExit {
  repeated RubyDiff terms = 1;
}

message Statements {
  repeated RubyDiff statements = 1;
}

message Try {
  RubyDiff tryBody = 1;
  repeated RubyDiff tryCatch = 2;
}

message While {
  RubyDiff whileCondition = 1;
  RubyDiff whileBody = 2;
}

message Yield {
  RubyDiff value = 1;
}

message RubySyntax {
  oneof syntax {
    Comment comment = 1;
    Function function = 2;
    Boolean boolean = 3;
    Method method = 4;
    File file = 5;
    Line line = 6;
    Plus plus = 7;
    Minus minus = 8;
    Times times = 9;
    DividedBy dividedBy = 10;
    Modulo modulo = 11;
    Power power = 12;
    Negate negate = 13;
    FloorDivision floorDivision = 14;
    BAnd bAnd = 15;
    BOr bOr = 16;
    BXOr bXOr = 17;
    LShift lShift = 18;
    RShift rShift = 19;
    Complement complement = 20;
    And and = 21;
    Not not = 22;
    Or or = 23;
    XOr xOr = 24;
    Call call = 25;
    LessThan lessThan = 26;
    LessThanEqual lessThanEqual = 27;
    GreaterThan greaterThan = 28;
    GreaterThanEqual greaterThanEqual = 29;
    Equal equal = 30;
    StrictEqual strictEqual = 31;
    Comparison comparison = 32;
    Enumeration enumeration = 33;
    Matches matches = 34;
    NotMatches notMatches = 35;
    MemberAccess memberAccess = 36;
    ScopeResolution scopeResolution = 37;
    Subscript subscript = 38;
    Member member = 39;
    This this = 40;
    Array array = 41;
    Character character = 42;
    Complex complex = 43;
    Float float = 44;
    Hash hash = 45;
    Integer integer = 46;
    InterpolationElement interpolationElement = 47;
    KeyValue keyValue = 48;
    Null null = 49;
    Rational rational = 50;
    Regex regex = 51;
    String string = 52;
    Symbol symbol = 53;
    SymbolElement symbolElement = 54;
    TextElement textElement = 55;
    Assignment assignment = 56;
    Break break = 57;
    Catch catch = 58;
    Continue continue = 59;
    Else else = 60;
    Finally finally = 61;
    ForEach forEach = 62;
    If if = 63;
    Match match = 64;
    Pattern pattern = 65;
    Retry retry = 66;
    Return return = 67;
    ScopeEntry scopeEntry = 68;
    ScopeExit scopeExit = 69;
    Statements statements = 70;
    Try try = 71;
    While while = 72;
    Yield yield = 73;
    Context context = 74;
    Empty empty = 75;
    Error error = 76;
    Identifier identifier = 77;
    Class class = 78;
    Load load = 79;
    LowPrecedenceAnd lowPrecedenceAnd = 80;
    LowPrecedenceOr lowPrecedenceOr = 81;
    Module module = 82;
    Require require = 83;
    Send send = 84;
    List list = 85;
  }
}

message Context {
  repeated RubyDiff contextTerms = 1;
  RubyDiff contextSubject = 2;
}

message Empty { }

message Identifier {
  bytes name = 1;
}

message List {
  repeated RubyDiff listContent = 1;
}
