// This file was generated by proto-gen. Do not edit by hand.
syntax = "proto3";

package github.semantic.rubyterm;

import "types.proto";

option java_package = "com.github.semantic.rubyterm";
option go_package = "github.com/semantic/rubyterm;ruby";

message RubyTerm {
  RubySyntax syntax = 1;
}

message RubySyntax {
  oneof syntax {
    Comment comment = 1;
    Function function = 2;
    Method method = 3;
    File file = 4;
    Line line = 5;
    Plus plus = 6;
    Minus minus = 7;
    Times times = 8;
    DividedBy dividedBy = 9;
    Modulo modulo = 10;
    Power power = 11;
    Negate negate = 12;
    FloorDivision floorDivision = 13;
    BAnd bAnd = 14;
    BOr bOr = 15;
    BXOr bXOr = 16;
    LShift lShift = 17;
    RShift rShift = 18;
    Complement complement = 19;
    And and = 20;
    Not not = 21;
    Or or = 22;
    XOr xOr = 23;
    Call call = 24;
    LessThan lessThan = 25;
    LessThanEqual lessThanEqual = 26;
    GreaterThan greaterThan = 27;
    GreaterThanEqual greaterThanEqual = 28;
    Equal equal = 29;
    StrictEqual strictEqual = 30;
    Comparison comparison = 31;
    Enumeration enumeration = 32;
    Matches matches = 33;
    NotMatches notMatches = 34;
    MemberAccess memberAccess = 35;
    ScopeResolution scopeResolution = 36;
    Subscript subscript = 37;
    Member member = 38;
    This this = 39;
    Array array = 40;
    Boolean boolean = 41;
    Character character = 42;
    Complex complex = 43;
    EscapeSequence escapeSequence = 44;
    Float float = 45;
    Hash hash = 46;
    Integer integer = 47;
    InterpolationElement interpolationElement = 48;
    KeyValue keyValue = 49;
    Null null = 50;
    Rational rational = 51;
    Regex regex = 52;
    String string = 53;
    Symbol symbol = 54;
    SymbolElement symbolElement = 55;
    TextElement textElement = 56;
    Assignment assignment = 57;
    Break break = 58;
    Catch catch = 59;
    Continue continue = 60;
    Else else = 61;
    Finally finally = 62;
    ForEach forEach = 63;
    If if = 64;
    Match match = 65;
    Pattern pattern = 66;
    Retry retry = 67;
    Return return = 68;
    ScopeEntry scopeEntry = 69;
    ScopeExit scopeExit = 70;
    Statements statements = 71;
    Try try = 72;
    While while = 73;
    Yield yield = 74;
    Context context = 75;
    Empty empty = 76;
    Error error = 77;
    Identifier identifier = 78;
    Class class = 79;
    Load load = 80;
    LowPrecedenceAnd lowPrecedenceAnd = 81;
    LowPrecedenceOr lowPrecedenceOr = 82;
    Module module = 83;
    Require require = 84;
    Send send = 85;
    List list = 86;
  }
}

message Comment {
  string commentContent = 1;
}

message Function {
  repeated RubyTerm functionContext = 1;
  RubyTerm functionName = 2;
  repeated RubyTerm functionParameters = 3;
  RubyTerm functionBody = 4;
}

message Method {
  repeated RubyTerm methodContext = 1;
  RubyTerm methodReceiver = 2;
  RubyTerm methodName = 3;
  repeated RubyTerm methodParameters = 4;
  RubyTerm methodBody = 5;
}

message File { }

message Line { }

message Plus {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Minus {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Times {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message DividedBy {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Modulo {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Power {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Negate {
  RubyTerm value = 1;
}

message FloorDivision {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message BAnd {
  RubyTerm left = 1;
  RubyTerm right = 2;
}

message BOr {
  RubyTerm left = 1;
  RubyTerm right = 2;
}

message BXOr {
  RubyTerm left = 1;
  RubyTerm right = 2;
}

message LShift {
  RubyTerm left = 1;
  RubyTerm right = 2;
}

message RShift {
  RubyTerm left = 1;
  RubyTerm right = 2;
}

message Complement {
  RubyTerm value = 1;
}

message And {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Not {
  RubyTerm value = 1;
}

message Or {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message XOr {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Call {
  repeated RubyTerm callContext = 1;
  RubyTerm callFunction = 2;
  repeated RubyTerm callParams = 3;
  RubyTerm callBlock = 4;
}

message LessThan {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message LessThanEqual {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message GreaterThan {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message GreaterThanEqual {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Equal {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message StrictEqual {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Comparison {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Enumeration {
  RubyTerm enumerationStart = 1;
  RubyTerm enumerationEnd = 2;
  RubyTerm enumerationStep = 3;
}

message Matches {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message NotMatches {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message MemberAccess {
  RubyTerm lhs = 1;
  bytes rhs = 2;
}

message ScopeResolution {
  repeated RubyTerm scopes = 1;
}

message Subscript {
  RubyTerm lhs = 1;
  repeated RubyTerm rhs = 2;
}

message Member {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message This { }

message Array {
  repeated RubyTerm arrayElements = 1;
}

message Boolean {
  bool booleanContent = 1;
}

message Character {
  string characterContent = 1;
}

message Complex {
  string value = 1;
}

message EscapeSequence {
  string value = 1;
}

message Float {
  string floatContent = 1;
}

message Hash {
  repeated RubyTerm hashElements = 1;
}

message Integer {
  string integerContent = 1;
}

message InterpolationElement {
  RubyTerm interpolationBody = 1;
}

message KeyValue {
  RubyTerm key = 1;
  RubyTerm value = 2;
}

message Null { }

message Rational {
  string value = 1;
}

message Regex {
  string regexContent = 1;
}

message String {
  repeated RubyTerm stringElements = 1;
}

message Symbol {
  repeated RubyTerm symbolElements = 1;
}

message SymbolElement {
  string symbolContent = 1;
}

message TextElement {
  string textElementContent = 1;
}

message Assignment {
  repeated RubyTerm assignmentContext = 1;
  RubyTerm assignmentTarget = 2;
  RubyTerm assignmentValue = 3;
}

message Break {
  RubyTerm value = 1;
}

message Catch {
  RubyTerm catchException = 1;
  RubyTerm catchBody = 2;
}

message Continue {
  RubyTerm value = 1;
}

message Else {
  RubyTerm elseCondition = 1;
  RubyTerm elseBody = 2;
}

message Finally {
  RubyTerm value = 1;
}

message ForEach {
  RubyTerm forEachBinding = 1;
  RubyTerm forEachSubject = 2;
  RubyTerm forEachBody = 3;
}

message If {
  RubyTerm ifCondition = 1;
  RubyTerm ifThenBody = 2;
  RubyTerm ifElseBody = 3;
}

message Match {
  RubyTerm matchSubject = 1;
  RubyTerm matchPatterns = 2;
}

message Pattern {
  RubyTerm value = 1;
  RubyTerm patternBody = 2;
}

message Retry {
  RubyTerm value = 1;
}

message Return {
  RubyTerm value = 1;
}

message ScopeEntry {
  repeated RubyTerm terms = 1;
}

message ScopeExit {
  repeated RubyTerm terms = 1;
}

message Statements {
  repeated RubyTerm statements = 1;
}

message Try {
  RubyTerm tryBody = 1;
  repeated RubyTerm tryCatch = 2;
}

message While {
  RubyTerm whileCondition = 1;
  RubyTerm whileBody = 2;
}

message Yield {
  RubyTerm value = 1;
}

message Context {
  repeated RubyTerm contextTerms = 1;
  RubyTerm contextSubject = 2;
}

message Empty { }

message Error {
  repeated ErrorSite errorCallStack = 1;
  repeated string errorExpected = 2;
  string errorActual = 3;
  repeated RubyTerm errorChildren = 4;
}

message Identifier {
  bytes name = 1;
}

message Class {
  RubyTerm classIdentifier = 1;
  repeated RubyTerm classSuperClass = 2;
  RubyTerm classBody = 3;
}

message Load {
  RubyTerm loadPath = 1;
  repeated RubyTerm loadWrap = 2;
}

message LowPrecedenceAnd {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message LowPrecedenceOr {
  RubyTerm lhs = 1;
  RubyTerm rhs = 2;
}

message Module {
  RubyTerm moduleIdentifier = 1;
  repeated RubyTerm moduleStatements = 2;
}

message Require {
  bool requireRelative = 1;
  RubyTerm requirePath = 2;
}

message Send {
  repeated RubyTerm sendReceiver = 1;
  repeated RubyTerm sendSelector = 2;
  repeated RubyTerm sendArgs = 3;
  repeated RubyTerm sendBlock = 4;
}

message List {
  repeated RubyTerm listContent = 1;
}
