{-# LANGUAGE DeriveAnyClass, FlexibleInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
module Main where

import Arguments
import Criterion.Main
import Data.Function
import Data.Functor.Listable
import Data.List (genericLength)
import Data.String
import Patch
import Prologue
import qualified Renderer as R
import SemanticDiff (fetchDiffs)
import qualified SemanticDiffPar
import SES
import System.Directory (makeAbsolute)
import Test.LeanCheck

main :: IO ()
main = do
  benchmarks <- sequenceA [ generativeBenchmarkWith "ses" 10 sesInputsOfLength (uncurry ((,) `on` length)) (nf (uncurry benchmarkSES)) ]
  defaultMain benchmarks
  -- defaultMain (syncAsyncBenchmark : benchmarks)
  where sesInputsOfLength n = listsOfLength n tiers >< listsOfLength n tiers

benchmarkSES :: [String] -> [String] -> [Either String (Patch String)]
benchmarkSES = ses compare cost
  where compare a b = if a == b then Just (Left a) else Nothing
        cost = either (const 0) (sum . fmap genericLength)

instance NFData a => NFData (Patch a)

-- | Defines a named group of n benchmarks over inputs generated by a 'Listable' instance.
--
--   The inputsâ€™ sizes at each iteration are measured by a metric function, which gives the name of the benchmark. This makes it convenient to correlate a benchmark of some function over e.g. lists with e.g. metric 'length'.
generativeBenchmark :: (Listable a, Show m, Ord m) => String -> Int -> (a -> m) -> (a -> Benchmarkable) -> IO Benchmark
generativeBenchmark name n = generativeBenchmarkWith name n (const tiers)

generativeBenchmarkWith :: (Show m, Ord m) => String -> Int -> (Int -> [Tier a]) -> (a -> m) -> (a -> Benchmarkable) -> IO Benchmark
generativeBenchmarkWith name n generate metric benchmark = do
  benchmarks <- traverse measure (take 2 (concat (generate n)))
  pure $! bgroup name (snd <$> sortOn fst benchmarks)
  where measure input = let measurement = metric input in pure $! (measurement, bench (show measurement) (benchmark input))

syncAsyncBenchmark :: Benchmark
syncAsyncBenchmark =
  bgroup "async vs par" [
      bench "async" . whnfIO $ SemanticDiff.fetchDiffs =<< theArgs,
      bench "par" . whnfIO $ SemanticDiffPar.fetchDiffs =<< theArgs
    ]

theArgs :: IO Arguments
theArgs = do
  jqueryPath <- makeAbsolute "test/repos/jquery"
  pure $ args jqueryPath sha1 sha2 files R.Patch
  where
    sha1 = "70526981916945dc4093e116a3de61b1777d4718"
    sha2 = "e5ffcb0838c894e26f4ff32dfec162cf624d8d7d"
    files = [
            "src/manipulation/getAll.js",
            "src/manipulation/support.js",
            "src/manipulation/wrapMap.js",
            "src/offset.js",
            "test/unit/css.js",
            "test/unit/deferred.js",
            "test/unit/deprecated.js",
            "test/unit/effects.js",
            "test/unit/event.js",
            "test/unit/offset.js",
            "test/unit/wrap.js"
            ]
