:undef source
:def source Prelude.readFile

:undef pretty
:def pretty \_ -> return "import Text.Show.Pretty (pPrint, ppShow)\nimport Language.Haskell.HsColour\nimport Language.Haskell.HsColour.Colourise\nlet colour = putStrLn . hscolour TTY defaultColourPrefs Prelude.False Prelude.False \"\" Prelude.False . ppShow\n:set -interactive-print colour\n"

:undef no-pretty
:def no-pretty \_ -> return ":set -interactive-print System.IO.print"

:undef re
:def re \_ -> return ":reload\n:pretty\n"

:{
assignmentExample lang = case lang of
  "Python" -> mk "py" "python"
  "Go" -> mk "go" "go"
  "Ruby" -> mk "rb" "ruby"
  "JavaScript" -> mk "js" "typescript"
  "TypeScript" -> mk "ts" "typescript"
  "Haskell" -> mk "hs" "haskell"
  "Markdown" -> mk "md" "markdown"
  "JSON" -> mk "json" "json"
  _ -> mk "" ""
  where mk fileExtension parser = putStrLn ("example: fmap (() <$) . runTask . parse " ++ parser ++ "Parser =<< Semantic.Util.file \"example." ++ fileExtension ++ "\"") >> return ("import Parser\nimport Semantic.Task\nimport Semantic.Util")
:}
:def assignment assignmentExample

:seti -fbreak-on-error

:set -Wwarn

:set prompt "\ESC[1;36m\STXÎ»: \ESC[m\STX"
